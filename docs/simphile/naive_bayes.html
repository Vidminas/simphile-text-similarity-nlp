<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>simphile.naive_bayes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>simphile.naive_bayes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from scipy import stats


class NaiveBayes:

    def __init__(self, prior_total, prior_positives):
        &#34;&#34;&#34;
        Initializes the Bayesian calculator with priors.

        :param prior_total: The total N.  In the spam example, this is the total number of emails
        :param prior_positives: The number of positives.  In the spam example, this is the count of spam emails
        &#34;&#34;&#34;
        assert prior_positives &lt; prior_total, &#34;must have prior_positives &lt; prior_total&#34;
        assert prior_positives &gt; 0, &#34;must have prior_positives &gt; 0&#34;
        assert prior_total &gt; 0, &#34;must have prior_total &gt; 0&#34;

        self.prior_positives = prior_positives
        self.prior_total = prior_total
        self.prior_negatives = prior_total - prior_positives
        self.alpha = 1
        self.observation_significance_threshold = 0.05
        self.observations = []

    def set_observation_significance_threshold(self, threshold):
        &#34;&#34;&#34;
        Any observation (aka test) that does not pass the p-value threshold will
        not be incorporated into the final prediction.  P-values are calculated
        with Fischer&#39;s Exact.  For example, if priors are 1000 with 300 positives,
        an observation sample of 100 with 30 positives won&#39;t be added because
        it does not differ significantly from the priors.  This keeps low value and
        potentially noisy observations out. The default threshold is 0.05

        :param threshold: can be a number between 0 and 0.5 or None

        :return:
        &#34;&#34;&#34;
        assert threshold is None or threshold &gt; 0
        assert threshold is None or threshold &lt; 0.5
        self.observation_significance_threshold = threshold

    def set_alpha(self, alpha):
        &#34;&#34;&#34;
        And alpha is a constant added to the positives to avoid zeros and generally smooths
        the results to avoid low-N and noisy samples throwing things off.  Default alpha is 1.0.

        :param alpha: a number greater than 0

        :return:
        &#34;&#34;&#34;
        assert alpha &gt;= 0
        self.alpha = alpha

    def add_observation(self, total, positives):
        &#34;&#34;&#34;
        An observation is the total population and number of positives for a given category.  For example,
        the total number of emails that contain &#34;money&#34; and the number of those emails that are spam.

        :param total: the total population count in the observation.
        For example the total number of emails that contain &#34;money&#34;

        :param positives: the number of positives in the population.
        For example the number of spam emails that contain &#34;money&#34;

        :return: True or False based on if the observation was significantly different from the prior likelihood
        &#34;&#34;&#34;
        assert positives &lt;= total, &#34;must have positives &lt;= total&#34;
        expectation = [self.prior_total, self.prior_positives]
        observation = [total, positives]
        table = [observation, expectation]
        p_value = stats.fisher_exact(table)[1]
        if self.observation_significance_threshold is None or p_value &lt;= self.observation_significance_threshold:
            self.observations.append(observation)
            return True   # observation added
        else:
            return False  # observation not added

    def calculate_probability(self):
        &#34;&#34;&#34;
        Given all the observations, uses Naive Bayes to calculate the probability
        ( 0 to 1) that a specific instance is true

        :return: the probability ( 0 to 1) that a specific instance is true (e.g.
        that a specific email is spam)
        &#34;&#34;&#34;
        prior_probability = self.prior_positives / self.prior_total
        alpha_denominator = self.alpha / prior_probability
        positive_score = prior_probability
        negative_score = 1.0 - prior_probability
        for observation in self.observations:
            observation_positives = self.alpha + observation[1]
            observation_total = alpha_denominator + observation[0]
            observation_negatives = observation_total - observation_positives
            positive_score *= observation_positives / (self.prior_positives + alpha_denominator)
            negative_score *= observation_negatives / (self.prior_negatives + alpha_denominator)
        return positive_score / (positive_score + negative_score)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="simphile.naive_bayes.NaiveBayes"><code class="flex name class">
<span>class <span class="ident">NaiveBayes</span></span>
<span>(</span><span>prior_total, prior_positives)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the Bayesian calculator with priors.</p>
<p>:param prior_total: The total N.
In the spam example, this is the total number of emails
:param prior_positives: The number of positives.
In the spam example, this is the count of spam emails</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NaiveBayes:

    def __init__(self, prior_total, prior_positives):
        &#34;&#34;&#34;
        Initializes the Bayesian calculator with priors.

        :param prior_total: The total N.  In the spam example, this is the total number of emails
        :param prior_positives: The number of positives.  In the spam example, this is the count of spam emails
        &#34;&#34;&#34;
        assert prior_positives &lt; prior_total, &#34;must have prior_positives &lt; prior_total&#34;
        assert prior_positives &gt; 0, &#34;must have prior_positives &gt; 0&#34;
        assert prior_total &gt; 0, &#34;must have prior_total &gt; 0&#34;

        self.prior_positives = prior_positives
        self.prior_total = prior_total
        self.prior_negatives = prior_total - prior_positives
        self.alpha = 1
        self.observation_significance_threshold = 0.05
        self.observations = []

    def set_observation_significance_threshold(self, threshold):
        &#34;&#34;&#34;
        Any observation (aka test) that does not pass the p-value threshold will
        not be incorporated into the final prediction.  P-values are calculated
        with Fischer&#39;s Exact.  For example, if priors are 1000 with 300 positives,
        an observation sample of 100 with 30 positives won&#39;t be added because
        it does not differ significantly from the priors.  This keeps low value and
        potentially noisy observations out. The default threshold is 0.05

        :param threshold: can be a number between 0 and 0.5 or None

        :return:
        &#34;&#34;&#34;
        assert threshold is None or threshold &gt; 0
        assert threshold is None or threshold &lt; 0.5
        self.observation_significance_threshold = threshold

    def set_alpha(self, alpha):
        &#34;&#34;&#34;
        And alpha is a constant added to the positives to avoid zeros and generally smooths
        the results to avoid low-N and noisy samples throwing things off.  Default alpha is 1.0.

        :param alpha: a number greater than 0

        :return:
        &#34;&#34;&#34;
        assert alpha &gt;= 0
        self.alpha = alpha

    def add_observation(self, total, positives):
        &#34;&#34;&#34;
        An observation is the total population and number of positives for a given category.  For example,
        the total number of emails that contain &#34;money&#34; and the number of those emails that are spam.

        :param total: the total population count in the observation.
        For example the total number of emails that contain &#34;money&#34;

        :param positives: the number of positives in the population.
        For example the number of spam emails that contain &#34;money&#34;

        :return: True or False based on if the observation was significantly different from the prior likelihood
        &#34;&#34;&#34;
        assert positives &lt;= total, &#34;must have positives &lt;= total&#34;
        expectation = [self.prior_total, self.prior_positives]
        observation = [total, positives]
        table = [observation, expectation]
        p_value = stats.fisher_exact(table)[1]
        if self.observation_significance_threshold is None or p_value &lt;= self.observation_significance_threshold:
            self.observations.append(observation)
            return True   # observation added
        else:
            return False  # observation not added

    def calculate_probability(self):
        &#34;&#34;&#34;
        Given all the observations, uses Naive Bayes to calculate the probability
        ( 0 to 1) that a specific instance is true

        :return: the probability ( 0 to 1) that a specific instance is true (e.g.
        that a specific email is spam)
        &#34;&#34;&#34;
        prior_probability = self.prior_positives / self.prior_total
        alpha_denominator = self.alpha / prior_probability
        positive_score = prior_probability
        negative_score = 1.0 - prior_probability
        for observation in self.observations:
            observation_positives = self.alpha + observation[1]
            observation_total = alpha_denominator + observation[0]
            observation_negatives = observation_total - observation_positives
            positive_score *= observation_positives / (self.prior_positives + alpha_denominator)
            negative_score *= observation_negatives / (self.prior_negatives + alpha_denominator)
        return positive_score / (positive_score + negative_score)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="simphile.naive_bayes.NaiveBayes.add_observation"><code class="name flex">
<span>def <span class="ident">add_observation</span></span>(<span>self, total, positives)</span>
</code></dt>
<dd>
<div class="desc"><p>An observation is the total population and number of positives for a given category.
For example,
the total number of emails that contain "money" and the number of those emails that are spam.</p>
<p>:param total: the total population count in the observation.
For example the total number of emails that contain "money"</p>
<p>:param positives: the number of positives in the population.
For example the number of spam emails that contain "money"</p>
<p>:return: True or False based on if the observation was significantly different from the prior likelihood</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_observation(self, total, positives):
    &#34;&#34;&#34;
    An observation is the total population and number of positives for a given category.  For example,
    the total number of emails that contain &#34;money&#34; and the number of those emails that are spam.

    :param total: the total population count in the observation.
    For example the total number of emails that contain &#34;money&#34;

    :param positives: the number of positives in the population.
    For example the number of spam emails that contain &#34;money&#34;

    :return: True or False based on if the observation was significantly different from the prior likelihood
    &#34;&#34;&#34;
    assert positives &lt;= total, &#34;must have positives &lt;= total&#34;
    expectation = [self.prior_total, self.prior_positives]
    observation = [total, positives]
    table = [observation, expectation]
    p_value = stats.fisher_exact(table)[1]
    if self.observation_significance_threshold is None or p_value &lt;= self.observation_significance_threshold:
        self.observations.append(observation)
        return True   # observation added
    else:
        return False  # observation not added</code></pre>
</details>
</dd>
<dt id="simphile.naive_bayes.NaiveBayes.calculate_probability"><code class="name flex">
<span>def <span class="ident">calculate_probability</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Given all the observations, uses Naive Bayes to calculate the probability
( 0 to 1) that a specific instance is true</p>
<p>:return: the probability ( 0 to 1) that a specific instance is true (e.g.
that a specific email is spam)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_probability(self):
    &#34;&#34;&#34;
    Given all the observations, uses Naive Bayes to calculate the probability
    ( 0 to 1) that a specific instance is true

    :return: the probability ( 0 to 1) that a specific instance is true (e.g.
    that a specific email is spam)
    &#34;&#34;&#34;
    prior_probability = self.prior_positives / self.prior_total
    alpha_denominator = self.alpha / prior_probability
    positive_score = prior_probability
    negative_score = 1.0 - prior_probability
    for observation in self.observations:
        observation_positives = self.alpha + observation[1]
        observation_total = alpha_denominator + observation[0]
        observation_negatives = observation_total - observation_positives
        positive_score *= observation_positives / (self.prior_positives + alpha_denominator)
        negative_score *= observation_negatives / (self.prior_negatives + alpha_denominator)
    return positive_score / (positive_score + negative_score)</code></pre>
</details>
</dd>
<dt id="simphile.naive_bayes.NaiveBayes.set_alpha"><code class="name flex">
<span>def <span class="ident">set_alpha</span></span>(<span>self, alpha)</span>
</code></dt>
<dd>
<div class="desc"><p>And alpha is a constant added to the positives to avoid zeros and generally smooths
the results to avoid low-N and noisy samples throwing things off.
Default alpha is 1.0.</p>
<p>:param alpha: a number greater than 0</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_alpha(self, alpha):
    &#34;&#34;&#34;
    And alpha is a constant added to the positives to avoid zeros and generally smooths
    the results to avoid low-N and noisy samples throwing things off.  Default alpha is 1.0.

    :param alpha: a number greater than 0

    :return:
    &#34;&#34;&#34;
    assert alpha &gt;= 0
    self.alpha = alpha</code></pre>
</details>
</dd>
<dt id="simphile.naive_bayes.NaiveBayes.set_observation_significance_threshold"><code class="name flex">
<span>def <span class="ident">set_observation_significance_threshold</span></span>(<span>self, threshold)</span>
</code></dt>
<dd>
<div class="desc"><p>Any observation (aka test) that does not pass the p-value threshold will
not be incorporated into the final prediction.
P-values are calculated
with Fischer's Exact.
For example, if priors are 1000 with 300 positives,
an observation sample of 100 with 30 positives won't be added because
it does not differ significantly from the priors.
This keeps low value and
potentially noisy observations out. The default threshold is 0.05</p>
<p>:param threshold: can be a number between 0 and 0.5 or None</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_observation_significance_threshold(self, threshold):
    &#34;&#34;&#34;
    Any observation (aka test) that does not pass the p-value threshold will
    not be incorporated into the final prediction.  P-values are calculated
    with Fischer&#39;s Exact.  For example, if priors are 1000 with 300 positives,
    an observation sample of 100 with 30 positives won&#39;t be added because
    it does not differ significantly from the priors.  This keeps low value and
    potentially noisy observations out. The default threshold is 0.05

    :param threshold: can be a number between 0 and 0.5 or None

    :return:
    &#34;&#34;&#34;
    assert threshold is None or threshold &gt; 0
    assert threshold is None or threshold &lt; 0.5
    self.observation_significance_threshold = threshold</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="simphile" href="index.html">simphile</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="simphile.naive_bayes.NaiveBayes" href="#simphile.naive_bayes.NaiveBayes">NaiveBayes</a></code></h4>
<ul class="">
<li><code><a title="simphile.naive_bayes.NaiveBayes.add_observation" href="#simphile.naive_bayes.NaiveBayes.add_observation">add_observation</a></code></li>
<li><code><a title="simphile.naive_bayes.NaiveBayes.calculate_probability" href="#simphile.naive_bayes.NaiveBayes.calculate_probability">calculate_probability</a></code></li>
<li><code><a title="simphile.naive_bayes.NaiveBayes.set_alpha" href="#simphile.naive_bayes.NaiveBayes.set_alpha">set_alpha</a></code></li>
<li><code><a title="simphile.naive_bayes.NaiveBayes.set_observation_significance_threshold" href="#simphile.naive_bayes.NaiveBayes.set_observation_significance_threshold">set_observation_significance_threshold</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>